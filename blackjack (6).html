<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Blackjack — 8-Deck Casino Table</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --felt:#0a5a2a; --felt-dark:#063d1c; --rail:#402a1a;
    --gold:#e9c46a; --btn-green:#27ae60; --btn-red:#c0392b; --btn-purple:#8e44ad; --btn-yellow:#f1c40f; --btn-blue:#264653;
    --text:#fff; --ink:#111;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; color:var(--text);
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:
      radial-gradient( circle at 30% 20%, rgba(255,255,255,0.06), transparent 35% ),
      radial-gradient( circle at 70% 80%, rgba(0,0,0,0.25), transparent 40% ),
      repeating-radial-gradient( circle at 20% 80%, rgba(255,255,255,0.05), rgba(255,255,255,0.05) 2px, transparent 3px, transparent 6px ),
      linear-gradient(135deg, var(--felt), var(--felt-dark));
  }
  header{ text-align:center; padding:18px 12px 6px; }
  h1{ margin:0; letter-spacing:.5px; font-weight:800; text-shadow:0 2px 0 rgba(0,0,0,.35); }
  .table{
    max-width:1100px; margin:10px auto 40px; padding:22px; border-radius:24px; position:relative;
    box-shadow: inset 0 0 0 3px rgba(255,255,255,0.06), 0 10px 40px rgba(0,0,0,.35);
    background:
      radial-gradient(120% 70% at 50% 10%, rgba(255,255,255,0.07), transparent 60%),
      radial-gradient(120% 70% at 50% 100%, rgba(0,0,0,0.25), transparent 60%);
  }
  .rail{ position:absolute; inset:-14px; border-radius:28px; box-shadow: inset 0 0 0 14px rgba(64,42,26,.85); pointer-events:none; }

  .row{ display:flex; gap:16px; flex-wrap:wrap; justify-content:center; }
  .pile{ min-height:110px; padding:10px; border-radius:18px; }
  .hand-title{ text-align:center; opacity:.95; font-weight:700; margin:6px 0; }
  .cards{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; min-height:100px; }

  /* Card */
  .card{
    width:64px; height:92px; border-radius:10px; background:#fff; color:var(--ink);
    display:flex; align-items:center; justify-content:center; font-weight:800; font-size:22px;
    box-shadow:0 4px 10px rgba(0,0,0,.35); position:relative;
  }
  .card.red{ color:#b00000; }
  .card .corner{ position:absolute; top:6px; left:6px; font-size:14px; font-weight:700; }
  .card .corner.br{ top:auto; left:auto; bottom:6px; right:6px; transform:rotate(180deg); }
  .card.back{ background: repeating-linear-gradient(45deg, #1b1e34 0 10px, #2e325a 10px 20px); color:#fff; }

  /* Multi-hand layout */
  .player-hands{ display:flex; flex-wrap:wrap; gap:18px; justify-content:center; }
  .hand-box{ padding:10px 12px; border-radius:16px; background:rgba(0,0,0,.18); box-shadow:inset 0 0 0 2px rgba(255,255,255,.06); min-width:260px; }
  .hand-header{ display:flex; gap:10px; justify-content:center; align-items:center; font-weight:800; }
  .badge{ padding:4px 8px; border-radius:999px; background:rgba(0,0,0,.3); font-size:.85rem; }
  .active .hand-header{ text-shadow:0 1px 0 rgba(0,0,0,.4); }
  .active{ outline: 2px solid rgba(255,255,255,.4); box-shadow:0 0 0 3px rgba(0,0,0,.25) inset; }

  /* HUD + Chips */
  .hud{ display:flex; justify-content:center; gap:18px; flex-wrap:wrap; margin:12px 0 2px; font-weight:800; }
  .pill{ background: rgba(0,0,0,.25); padding:8px 12px; border-radius:999px; box-shadow: inset 0 0 0 2px rgba(255,255,255,.06); }
  .status{ text-align:center; font-size:1.05rem; margin:10px 0 2px; font-weight:800; text-shadow:0 1px 0 rgba(0,0,0,.35); min-height:1.2em; }
  .bet-circle{ width:84px; height:84px; border-radius:50%; margin:14px auto 0; display:flex; align-items:center; justify-content:center;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.25), rgba(255,255,255,0) 40%), rgba(0,0,0,.25);
    border:3px dashed rgba(255,255,255,.35); font-weight:900; }
  .chips{ display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:10px; }
  .chip{ width:60px; height:60px; border-radius:50%; position:relative; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:900; font-size:14px;
    color:#fff; text-shadow:0 1px 0 rgba(0,0,0,.4); box-shadow: 0 6px 14px rgba(0,0,0,.35), inset 0 0 0 4px rgba(255,255,255,.15); user-select:none; }
  .chip span{ background:rgba(0,0,0,.25); padding:4px 8px; border-radius:999px; }
  .chip.white{ background:#f8f9fa; color:#111; text-shadow:none; box-shadow:0 6px 14px rgba(0,0,0,.35), inset 0 0 0 4px rgba(0,0,0,.08); }
  .chip.red{ background:#d62828; } .chip.green{ background:#2a9d8f; } .chip.blue{ background:#1d3557; } .chip.black{ background:#111; }

  /* Controls */
  .controls{ display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin-top:16px; }
  button{ border:0; border-radius:999px; padding:12px 18px; font-weight:800; cursor:pointer; box-shadow:0 4px 14px rgba(0,0,0,.2);
    transition: transform .03s ease, opacity .12s ease; color:#fff; }
  button:active{ transform: translateY(1px); }
  button:disabled{ opacity:.45; cursor:not-allowed; }
  .btn-deal{ background: var(--gold); color:#231; }
  .btn-clear{ background: var(--btn-blue); }
  .btn-hit{ background: var(--btn-green); }
  .btn-stand{ background: var(--btn-red); }
  .btn-double{ background: var(--btn-purple); }
  .btn-split{ background: var(--btn-yellow); color:#222; }
  .btn-new{ background: #e76f51; }
  .btn-request{ background:#ff8c00; color:#231; }
  .btn-reset{ background:#555; }

  @media (max-width:600px){
    .card{ width:56px; height:84px; }
    .chip{ width:56px; height:56px; font-size:13px; }
    .bet-circle{ width:76px; height:76px; }
    .hand-box{ min-width:240px; }
  }
</style>
</head>
<body>
  <header><h1>♠️ Blackjack — 8-Deck Shoe ♥️</h1></header>

  <main class="table">
    <div class="rail"></div>

    <!-- Dealer -->
    <section class="pile">
      <div class="hand-title">Dealer: <span id="dealer-total">0</span></div>
      <div id="dealer-cards" class="cards"></div>
    </section>

    <!-- Player (multi-hand) -->
    <section class="pile">
      <div class="hand-title">Your Hands</div>
      <div id="player-hands" class="player-hands"></div>
    </section>

    <!-- HUD -->
    <div class="hud">
      <div class="pill">Balance: $<span id="balance">1000</span></div>
      <div class="pill">Total Bet: $<span id="bet">0</span></div>
      <div class="pill">Phase: <span id="phase-label">Betting</span></div>
    </div>
    <div class="bet-circle">$<span id="bet-big">0</span></div>

    <div class="status" id="status">Place your bet to begin.</div>

    <!-- Chips -->
    <div class="chips" id="chip-row">
      <div class="chip white" data-amt="5"><span>$5</span></div>
      <div class="chip red" data-amt="25"><span>$25</span></div>
      <div class="chip green" data-amt="100"><span>$100</span></div>
      <div class="chip blue" data-amt="250"><span>$250</span></div>
      <div class="chip black" data-amt="500"><span>$500</span></div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button class="btn-deal" id="deal-btn" disabled>Deal</button>
      <button class="btn-clear" id="clear-bet-btn">Clear Bet</button>
      <button class="btn-hit" id="hit-btn" disabled>Hit</button>
      <button class="btn-stand" id="stand-btn" disabled>Stand</button>
      <button class="btn-double" id="double-btn" disabled>Double</button>
      <button class="btn-split" id="split-btn" disabled>Split</button>
      <button class="btn-new" id="new-round-btn" disabled>New Round</button>
      <button class="btn-request" id="request-btn" style="display:none;">Request Funds</button>
      <button class="btn-reset" id="reset-bankroll-btn">Reset Bankroll</button>
    </div>
  </main>

<script>
  // =================== CONFIG ===================
  const SHOE_DECKS = 8;        // fixed 8-deck shoe
  const RESHUFFLE_AT = 52;     // reshuffle when < 1 deck remains
  const LS_BALANCE_KEY = 'bj_balance';
  const LS_HISTORY_KEY = 'bj_history'; // array of round objects
  const LS_FUND_REQ_KEY = 'fund_requests';

  // =================== STATE ====================
  let shoe = [];
  let balance = 1000;

  // Betting
  let pendingBet = 0; // during betting phase before initial deal

  // Round
  // playerHands: array of { cards:[], bet:number, doubled:boolean, done:boolean, result:null|'win'|'lose'|'push'|'bj' }
  let playerHands = [];
  let activeHandIndex = 0;
  let dealerHand = [];
  let dealerHoleRevealed = false;
  let phase = 'betting'; // betting | player | dealer | roundOver

  // =================== DOM ======================
  const $ = (id)=>document.getElementById(id);
  const elDealerCards = $('dealer-cards');
  const elDealerTotal = $('dealer-total');
  const elPlayerHands = $('player-hands');
  const elBalance = $('balance');
  const elBet = $('bet');
  const elBetBig = $('bet-big');
  const elPhase = $('phase-label');
  const statusEl = $('status');

  const dealBtn = $('deal-btn');
  const clearBetBtn = $('clear-bet-btn');
  const hitBtn = $('hit-btn');
  const standBtn = $('stand-btn');
  const doubleBtn = $('double-btn');
  const splitBtn = $('split-btn');
  const newRoundBtn = $('new-round-btn');
  const requestBtn = $('request-btn');
  const resetBankrollBtn = $('reset-bankroll-btn');

  // =================== INIT =====================
  loadPersisted();
  setupButtons();
  setButtonsForPhase();
  renderAll();

  // =================== PERSISTENCE ==============
  function loadPersisted(){
    try {
      const b = localStorage.getItem(LS_BALANCE_KEY);
      if (b !== null && !Number.isNaN(Number(b))) balance = Math.max(0, Math.floor(Number(b)));
    } catch(e){}
  }
  function saveBalance(){
    try{ localStorage.setItem(LS_BALANCE_KEY, String(balance)); }catch(e){}
  }
  function pushHistory(entry){
    try{
      const arr = JSON.parse(localStorage.getItem(LS_HISTORY_KEY) || '[]');
      arr.push(entry);
      localStorage.setItem(LS_HISTORY_KEY, JSON.stringify(arr));
    }catch(e){}
    supabaseInsert('bj_hands', entry);
  }
  function saveFundRequest(payload){
    try{
      const arr = JSON.parse(localStorage.getItem(LS_FUND_REQ_KEY)||'[]');
      arr.push(payload);
      localStorage.setItem(LS_FUND_REQ_KEY, JSON.stringify(arr));
    }catch(e){}
  }

  // =================== SUPABASE HOOKS ===========
  async function supabaseInsert(table, data){
    try{
      if (window.supabase && typeof window.supabase.from === 'function'){
        const { error } = await window.supabase.from(table).insert(data);
        if (error) console.warn('Supabase insert error:', error.message);
      }
    }catch(err){ console.warn('Supabase not configured or insert failed.', err); }
  }
  async function supabaseFundRequest(payload){
    try{
      if (window.supabase && typeof window.supabase.from === 'function'){
        const { error } = await window.supabase.from('fund_requests').insert(payload);
        if (error) console.warn('Supabase fund request error:', error.message);
      }
    }catch(err){ /* ignore */ }
  }

  // =================== SHOE / CARDS =============
  function buildShoe(){
    const suits = ['♠','♥','♦','♣'];
    const vals = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    const s = [];
    for (let d=0; d<SHOE_DECKS; d++){
      for (const s1 of suits){ for (const v of vals){ s.push({s:s1, v}); } }
    }
    for (let i = s.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [s[i], s[j]] = [s[j], s[i]];
    }
    return s;
  }
  function drawCard(){
    if (shoe.length <= RESHUFFLE_AT){ shoe = buildShoe(); }
    return shoe.pop();
  }
  function cardValue(c){ if (['J','Q','K'].includes(c.v)) return 10; if (c.v==='A') return 11; return parseInt(c.v,10); }
  function isTenVal(c){ return ['10','J','Q','K'].includes(c.v); }
  function handValue(hand){
    let total=0, aces=0;
    for (const c of hand){ total += cardValue(c); if (c.v==='A') aces++; }
    while (total>21 && aces>0){ total-=10; aces--; }
    return total;
  }

  // =================== RENDERING ================
  function renderCard(card, back=false){
    const div = document.createElement('div');
    if (back){ div.className='card back'; return div; }
    const isRed = (card.s==='♥' || card.s==='♦');
    div.className='card'+(isRed?' red':'');
    div.innerHTML = `<div class="corner">${card.v}${card.s}</div>${card.v}${card.s}<div class="corner br">${card.v}${card.s}</div>`;
    return div;
  }

  function renderHands(){
    elDealerCards.innerHTML = '';
    dealerHand.forEach((c, idx)=>{
      const hideHole = (idx===1 && !dealerHoleRevealed && phase!=='dealer' && phase!=='roundOver');
      elDealerCards.appendChild(renderCard(c, hideHole));
    });
    elDealerTotal.textContent = dealerHoleRevealed ? handValue(dealerHand)
                          : (dealerHand.length ? cardValue(dealerHand[0]) : 0);

    elPlayerHands.innerHTML = '';
    playerHands.forEach((h, i)=>{
      const box = document.createElement('div');
      box.className = 'hand-box'+(i===activeHandIndex && phase==='player' ? ' active' : '');
      const header = document.createElement('div');
      header.className = 'hand-header';
      header.innerHTML = `<div class="badge">Hand ${i+1}</div>
                          <div class="badge">Bet $${h.bet}</div>
                          <div class="badge">Total ${handValue(h.cards)}</div>
                          ${h.doubled ? '<div class="badge">Doubled</div>' : ''}`;
      const cardsWrap = document.createElement('div');
      cardsWrap.className='cards';
      h.cards.forEach(c=>cardsWrap.appendChild(renderCard(c,false)));
      box.appendChild(header); box.appendChild(cardsWrap);
      elPlayerHands.appendChild(box);
    });
  }

  function renderHUD(){
    elBalance.textContent = balance;
    elBet.textContent = totalCurrentBet();
    elBetBig.textContent = pendingBet;
    elPhase.textContent =
      phase==='betting' ? 'Betting' : phase==='player' ? `Player Turn (Hand ${activeHandIndex+1} of ${playerHands.length})`
      : phase==='dealer' ? 'Dealer Turn' : 'Round Over';
    requestBtn.style.display = (phase==='betting' && balance < 5 && pendingBet===0) ? 'inline-block' : 'none';
  }

  function renderAll(){ renderHands(); renderHUD(); }

  // =================== CONTROLS =================
  function setButtonsForPhase(){
    if (phase==='betting'){
      dealBtn.disabled = pendingBet<=0;
      clearBetBtn.disabled = pendingBet<=0;
      hitBtn.disabled = true; standBtn.disabled = true; doubleBtn.disabled = true; splitBtn.disabled = true;
      newRoundBtn.disabled = true;
    } else if (phase==='player'){
      dealBtn.disabled = true; clearBetBtn.disabled = true; newRoundBtn.disabled = true;
      const h = playerHands[activeHandIndex];
      hitBtn.disabled = false;
      standBtn.disabled = false;
      doubleBtn.disabled = !(h && h.cards.length===2 && balance>=h.bet);
      splitBtn.disabled = !(h && canSplit(h) && balance>=h.bet);
    } else if (phase==='dealer'){
      hitBtn.disabled = true; standBtn.disabled = true; doubleBtn.disabled = true; splitBtn.disabled = true;
      dealBtn.disabled = true; clearBetBtn.disabled = true; newRoundBtn.disabled = true;
    } else {
      hitBtn.disabled = true; standBtn.disabled = true; doubleBtn.disabled = true; splitBtn.disabled = true;
      dealBtn.disabled = true; clearBetBtn.disabled = true; newRoundBtn.disabled = false;
    }
  }

  function setupButtons(){
    document.querySelectorAll('.chip').forEach(chip=>{
      chip.addEventListener('click', ()=>{
        if (phase!=='betting') return;
        const amt = Number(chip.dataset.amt);
        if (balance >= amt){
          balance -= amt; saveBalance();
          pendingBet += amt;
          statusEl.textContent = 'Betting…';
          setButtonsForPhase(); renderHUD();
          dealBtn.disabled = pendingBet<=0;
        }
      });
    });

    clearBetBtn.addEventListener('click', ()=>{
      if (phase!=='betting') return;
      balance += pendingBet; saveBalance();
      pendingBet = 0; statusEl.textContent = 'Bet cleared.';
      setButtonsForPhase(); renderHUD();
    });

    dealBtn.addEventListener('click', startHand);

    hitBtn.addEventListener('click', ()=>{
      if (phase!=='player') return;
      const h = playerHands[activeHandIndex];
      h.cards.push(drawCard());
      renderAll(); checkPlayerHandEnd(h);
    });

    standBtn.addEventListener('click', ()=>{
      if (phase!=='player') return;
      playerHands[activeHandIndex].done = true;
      advanceTurn();
    });

    doubleBtn.addEventListener('click', ()=>{
      if (phase!=='player') return;
      const h = playerHands[activeHandIndex];
      if (h.cards.length===2 && balance>=h.bet){
        balance -= h.bet; saveBalance();
        h.bet *= 2; h.doubled = true;
        h.cards.push(drawCard());
        renderAll();
        h.done = true;
        advanceTurn();
      }
    });

    splitBtn.addEventListener('click', ()=>{
      if (phase!=='player') return;
      const idx = activeHandIndex;
      const h = playerHands[idx];
      if (!canSplit(h) || balance < h.bet) return;
      balance -= h.bet; saveBalance();

      const c1 = h.cards[0], c2 = h.cards[1];
      const h1 = {cards:[c1, drawCard()], bet:h.bet, doubled:false, done:false, result:null};
      const h2 = {cards:[c2, drawCard()], bet:h.bet, doubled:false, done:false, result:null};
      playerHands.splice(idx, 1, h1);
      playerHands.splice(idx+1, 0, h2);

      statusEl.textContent = `Split into two hands. Playing Hand ${idx+1} first.`;
      renderAll(); setButtonsForPhase();
    });

    newRoundBtn.addEventListener('click', ()=>{
      pendingBet = 0;
      playerHands = []; dealerHand = []; dealerHoleRevealed=false; phase='betting';
      statusEl.textContent = 'Place your bet to begin.';
      renderAll(); setButtonsForPhase();
    });

    requestBtn.addEventListener('click', ()=>{
      const amtStr = prompt('Enter amount to request:');
      const amt = Math.floor(Number(amtStr||0));
      if (!amt || amt<=0) return;
      const payload = { amount: amt, ts: Date.now(), player: 'anonymous' };
      saveFundRequest(payload);
      if (typeof window.onFundsRequest === 'function'){
        try { window.onFundsRequest(payload); } catch(e){ console.warn('onFundsRequest hook error:', e); }
      }
      supabaseFundRequest(payload);
      statusEl.textContent = 'Funds request submitted to admin.';
    });

    resetBankrollBtn.addEventListener('click', ()=>{
      const ok = confirm('Reset bankroll to $1000?');
      if (!ok) return;
      balance = 1000; saveBalance();
      renderHUD();
    });
  }

  // =================== GAME FLOW =================
  function startHand(){
    if (phase!=='betting' || pendingBet<=0) return;
    if (shoe.length<=RESHUFFLE_AT){ shoe = buildShoe(); }

    playerHands = [{ cards:[], bet: pendingBet, doubled:false, done:false, result:null }];
    pendingBet = 0;
    dealerHand = [];
    dealerHoleRevealed = false;
    activeHandIndex = 0;

    playerHands[0].cards.push(drawCard());
    dealerHand.push(drawCard());
    playerHands[0].cards.push(drawCard());
    dealerHand.push(drawCard());

    phase = 'player';
    statusEl.textContent = 'Your move: Hit, Stand, Double, or Split.';
    renderAll(); setButtonsForPhase();

    const pv = handValue(playerHands[0].cards);
    const dv = handValue(dealerHand);
    if (pv===21 || dv===21){
      dealerHoleRevealed = true; renderAll();
      if (pv===21 && dv===21){ statusEl.textContent='Both Blackjack — Push.'; settleRoundAfterDealer(true); }
      else if (pv===21){ statusEl.textContent='Blackjack! You win 3:2 🎉'; playerHands[0].result='bj'; settleRoundAfterDealer(true); }
      else { statusEl.textContent='Dealer Blackjack. House wins.'; settleRoundAfterDealer(true, 'dealerBJ'); }
    }
  }

  function canSplit(h){
    if (!h || h.cards.length!==2) return false;
    const a=h.cards[0], b=h.cards[1];
    return (a.v===b.v) || (isTenVal(a) && isTenVal(b));
  }

  function checkPlayerHandEnd(h){
    const val = handValue(h.cards);
    if (val>21){ h.done = true; statusEl.textContent = `Hand ${activeHandIndex+1} busted.`; advanceTurn(); }
    else { setButtonsForPhase(); }
  }

  function advanceTurn(){
    for (let i=activeHandIndex+1; i<playerHands.length; i++){
      if (!playerHands[i].done){ activeHandIndex=i; renderAll(); setButtonsForPhase(); statusEl.textContent=`Hand ${i+1}: your move.`; return; }
    }
    phase='dealer'; dealerHoleRevealed=true; renderAll(); setButtonsForPhase();
    dealerPlay();
  }

  function dealerPlay(){
    statusEl.textContent = 'Dealer’s turn…';
    let dv = handValue(dealerHand);
    while (dv < 17){
      dealerHand.push(drawCard()); renderAll(); dv = handValue(dealerHand);
    }
    settleRoundAfterDealer();
  }

  function settleRoundAfterDealer(immediate=false){
    const dealerTotal = handValue(dealerHand);
    let totalPayout = 0;

    for (const h of playerHands){
      const pv = handValue(h.cards);
      if (h.result==='bj'){
        totalPayout += Math.floor(h.bet * 2.5);
        h.result = 'win';
        continue;
      }
      if (pv>21){ h.result='lose'; continue; }
      if (dealerTotal>21){ totalPayout += h.bet*2; h.result='win'; continue; }
      if (pv>dealerTotal){ totalPayout += h.bet*2; h.result='win'; continue; }
      if (pv===dealerTotal){ totalPayout += h.bet; h.result='push'; continue; }
      h.result='lose';
    }

    balance += totalPayout; saveBalance();

    phase='roundOver';
    const summary = summarizeResults(playerHands);
    statusEl.textContent = summary;

    const entry = {
      ts: Date.now(),
      dealerUp: dealerHand[0] ? dealerHand[0].v + dealerHand[0].s : null,
      dealerTotal,
      hands: playerHands.map(h => ({
        bet: h.bet,
        total: handValue(h.cards),
        cards: h.cards.map(c=>c.v+c.s),
        doubled: !!h.doubled,
        result: h.result
      })),
      payout: totalPayout
    };
    pushHistory(entry);

    renderAll(); setButtonsForPhase();
  }

  function summarizeResults(hands){
    const wins = hands.filter(h=>h.result==='win').length;
    const pushes = hands.filter(h=>h.result==='push').length;
    const losses = hands.filter(h=>h.result==='lose').length;
    return `Results — Wins: ${wins}, Pushes: ${pushes}, Losses: ${losses}.`;
  }

  function totalCurrentBet(){
    const live = playerHands.reduce((sum,h)=>sum+h.bet,0);
    return live + pendingBet;
  }
</script>
</body>
</html>
